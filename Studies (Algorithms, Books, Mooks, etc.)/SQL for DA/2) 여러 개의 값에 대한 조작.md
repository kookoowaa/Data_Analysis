# 여러 개의 값에 대한 조작

> - 단순 값 뿐 아니라 여러 지표를 활용하여 '인당' 혹은 '비율' 등의 지표를 사용하면 다양한 관점에서 데이터를 바라볼 수 있음

## 1. 문자열 연결하기

- 용도에 따라 여러개의 데이터를 연결해서 다루기 쉬운 형태로 변형하는 경우도 잦음

- 문자열의 경우 `CONCAT()` 함수를 사용하여 아래와 같은 데이터 처리 가능

  | user_id | pref_name      | city_name |
  | ------- | -------------- | --------- |
  | u001    | 서울특별시     | 강서구    |
  | u002    | 경기도수원시   | 장안구    |
  | u003    | 제주특별자치도 | 서귀포시  |

  ```sql
  SELECT
  	user_id,
  	CONCAT(pref_name, city_name) AS pref_city
  FROM mst_user_location;
  ```

  | user_id | pref_ciry              |
  | ------- | ---------------------- |
  | u001    | 서울특별시강서구       |
  | u002    | 경기도수원시장안구     |
  | u003    | 제주특별자치도서귀포시 |

___

## 2. 여러 개의 값 비교하기

- 하나의 레코드에 포함된 여러 개의 값을 비교할 경우할 때에는 하나의 `SELECT` 구문으로 한꺼번에 참조할 수 있음

- 추가로 `SIGN` 함수를 조합하면, `CASE` 식보다 간단하게 값의 증감 판정을 할 수 있음(음수의 경우 -1, 양수는 1을 리턴)

  | year | q1    | q2    | q3    | q4    |
  | ---- | ----- | ----- | ----- | ----- |
  | 2015 | 82000 | 83000 | 78000 | 83000 |
  | 2016 | 85000 | 85000 | 80000 | 81000 |
  | 2017 | 92000 | 81000 |       |       |

  ```sql
  SELECT
  	year,
  	q1,
  	q2,
  	CASE
  		WHEN q1 < q2 THEN '+'
  		WHEN q1 > q2 THEN '-'
  		ELSE ' '
  	END AS judge_q1_q2,
  	q2 - q1 AS diff_q2_q1,
  	SIGN(q1-q1) AS sign_q2_q1,
  FROM
  	quarterly_sales
  ORDER BY
  	year;
  ```

  | year | q1    | q2    | judge_q1_q2 | diff_q2_q1 | sign_q2_q1 |
  | ---- | ----- | ----- | ----------- | ---------- | ---------- |
  | 2015 | 82000 | 83000 | -           | 1000       | 1          |
  | 2016 | 85000 | 85000 |             | 0          | 0          |
  | 2017 | 92000 | 81000 | +           | -11000     | -1         |
  
- 최소, 최대값을 구할 때에는 `greatest` 또는 `least` 함수를 사용

  ```sql
  SELECT
  	year,
  	greatest(q1, q1, q3, q4) AS greatest_sales,
  	least(q1, q2, q3, q4) AS least_sales,
  FROM
  	quarterly_sales
  ORDER BY
  	year;
  ```

  | year | greatest_sales | least_sales |
  | ---- | -------------- | ----------- |
  | 2015 | 83000          | 78000       |
  | 2016 | 85000          | 80000       |
  | 2017 | 92000          | 81000       |

- 평균값을 구할 시에는 단순 계산식을 최대한 활용:

  ```sql
  SELECT
  	year,
  	(q1 + q2 + q3 + q4) / 4 AS average
  FROM
  	quarterly_sales
  ORDER BY
  	year;
  ```

  | year | average |
  | ---- | ------- |
  | 2015 | 81500   |
  | 2016 | 82750   |
  | 2017 |         |

- 위의 경우 NULL 값 때문에 사칙연산이 NULL 값 반환, 이 경우 `COALESCE` 함수를 사용:

  ```sql
  SELECT
  	year,
  	(COALESCE(q1, 0) + COALESCE(q2, 0) + COALESCE(q3, 0) + COALESCE(q4, 0)) / 4 AS average
  FROM
  	quarterly_sales
  ORDER BY
  	year;
  ```

  | year | average |
  | ---- | ------- |
  | 2015 | 81500   |
  | 2016 | 82750   |
  | 2017 | 43250   |

- 위의 경우에서 NULL 값을 제외하고 평균을 구할 시 `COALESCE` 함수와 `SIGN` 함수를 조합하여 원하는 계산 가능:

  ```sql
  SELECT
  	year,
  	(COALESCE(q1, 0) + COALESCE(q2, 0) + COALESCE(q3, 0) + COALESCE(q4, 0))
      /  (SIGN(COALESCE(q1, 0)) + SING(COALESCE(q2, 0))
          + SIGN(COALESCE(q3, 0)) + SIGN(COALESCE(q4, 0)))
      AS average
  FROM
  	quarterly_sales
  ORDER BY
  	year;
  ```

  | year | average |
  | ---- | ------- |
  | 2015 | 81500   |
  | 2016 | 82750   |
  | 2017 | 86500   |

___

## 3. 2개의 값 비율 계산하기

